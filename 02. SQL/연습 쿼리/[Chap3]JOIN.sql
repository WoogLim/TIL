SELECT T1.COL_1, T2.COL_1
FROM   (    SELECT 'A' COL_1 FROM DUAL UNION ALL
            SELECT 'B' COL_1 FROM DUAL UNION ALL
            SELECT 'C' COL_1 FROM DUAL ) T1
       ,(   SELECT 'A' COL_1 FROM DUAL UNION ALL
            SELECT 'B' COL_1 FROM DUAL UNION ALL
            SELECT 'B' COL_1 FROM DUAL UNION ALL
            SELECT 'D' COL_1 FROM DUAL ) T2
WHERE   T1.COL_1 = T2.COL_1;

-- (2) INNER-JOIN의 처리 과정
SELECT  T1.CUS_ID, T1.CUS_GD, T2.ORD_SEQ, T2.CUS_ID, T2.ORD_DT
FROM    M_CUS T1
        ,T_ORD T2
WHERE   T1.CUS_ID = T2.CUS_ID
AND     T1.CUS_GD = 'A'
AND     T2.ORD_DT >= TO_DATE('20170101','YYYYMMDD')
AND     T2.ORD_DT <  TO_DATE('20170201','YYYYMMDD')
AND     T1.CUS_ID = 'CUS_0003';

-- 잘못된 쿼리의 예
-- 특정 고객의 17년 3월의 아이템평가(T_ITM_EVL)기록과 3월 주문(T_ORD)에 대해, 고객 ID, 고객명별 아이템평가 건수, 주문건수를 출력
SELECT  T1.CUS_ID, T1.CUS_NM
        ,COUNT( T2.ITM_ID||'-'||TO_CHAR(T2.EVL_LST_NO)) EVAL_CNT
        ,COUNT( T3.ORD_SEQ) ORD_CNT
FROM    M_CUS T1
        ,T_ITM_EVL T2
        ,T_ORD T3
WHERE   T1.CUS_ID = T2.CUS_ID
AND     T1.CUS_ID = T3.CUS_ID
AND     T1.CUS_ID = 'CUS_0023'
AND     T2.EVL_DT >= TO_DATE('20170301','YYYYMMDD')
AND     T2.EVL_DT <  TO_DATE('20170401','YYYYMMDD')
AND     T3.ORD_DT >= TO_DATE('20170301','YYYYMMDD')
AND     T3.ORD_DT <  TO_DATE('20170401','YYYYMMDD')
GROUP BY T1.CUS_ID, T1.CUS_NM;

SELECT  T1.CUS_ID
        ,T1.CUS_NM
        ,T2.EVL_CNT
        ,T3.ORD_CNT
  FROM  M_CUS T1
        ,(
        SELECT  T2.CUS_ID
                ,COUNT(*) EVL_CNT
          FROM T_ITM_EVL T2
         WHERE T2.CUS_ID = 'CUS_0023'
           AND T2.EVL_DT >= TO_DATE('20170301','YYYYMMDD')
           AND T2.EVL_DT < TO_DATE('20170401','YYYYMMDD')
         GROUP BY T2.CUS_ID
         ) T2
         ,(
        SELECT  T3.CUS_ID
                ,COUNT(*) ORD_CNT
          FROM T_ORD T3
         WHERE T3.CUS_ID = 'CUS_0023'
           AND T3.ORD_DT >= TO_DATE('20170301','YYYYMMDD')
           AND T3.ORD_DT < TO_DATE('20170401','YYYYMMDD')
         GROUP BY T3.CUS_ID
         ) T3
  WHERE  T1.CUS_ID = T2.CUS_ID
    AND  T1.CUS_ID = T3.CUS_ID
    AND  T1.CUS_ID = 'CUS_0023';
    
-- 1. CASE를 이용해 가격유형(ORD_AMT_TP)별로 주문 건수를 카운트
SELECT  T1.ORD_ST
        ,CASE WHEN T1.ORD_AMT >= 5000 THEN 'HIGH ORDER'
              WHEN T1.ORD_AMT >= 3000 THEN 'MIDDLE ORDER'
              ELSE 'LOW ORDER'
              END ORD_AMT_TP
        ,COUNT(*) ORD_CNT
  FROM  T_ORD T1
GROUP BY T1.ORD_ST
        ,CASE WHEN T1.ORD_AMT >= 5000 THEN 'HIGH ORDER'
              WHEN T1.ORD_AMT >= 3000 THEN 'MIDDLE ORDER'
              ELSE 'LOW ORDER'
              END
ORDER BY 1, 2;

-- 주문금액유형 테이블 생성
CREATE TABLE M_ORD_AMT_TP
(
    ORD_AMT_TP VARCHAR2(40) NOT NULL,
    FR_AMT NUMBER(18, 3) NULL,
    TO_AMT NUMBER(18, 3) NULL
);

CREATE UNIQUE INDEX PK_M_ORD_AMT_TP ON M_ORD_AMT_TP(ORD_AMT_TP);

ALTER TABLE M_ORD_AMT_TP
        ADD CONSTRAINT PK_M_ORD_AMT_TP PRIMARY KEY(ORD_AMT_TP) USING INDEX;

-- 테스트 데이터 생성.
INSERT INTO M_ORD_AMT_TP(ORD_AMT_TP, FR_AMT, TO_AMT)
SELECT 'Low Order', 0, 3000 FROM DUAL UNION ALL
SELECT 'Middle Order', 3000, 5000 FROM DUAL UNION ALL
SELECT 'High Order', 5000, 999999999999 FROM DUAL;

COMMIT;

-- RANGE-JOIN을 이용해 가격유형(ORD_AMT_TP)별로 주문 건수를 카운트
SELECT  T1.ORD_ST, T2.ORD_AMT_TP, COUNT(*) ORD_CNT
  FROM  T_ORD T1
        , M_ORD_AMT_TP T2
 WHERE  NVL(T1.ORD_AMT,0) >= T2.FR_AMT
   AND  NVL(T1.ORD_AMT,0) <  T2.TO_AMT
 GROUP BY T1.ORD_ST, T2.ORD_AMT_TP
 ORDER BY 1, 2;
 
-- OUTER 조인, 한 명은 평가가 있지만 한 명은 평가가 없음.
SELECT  T1.CUS_ID, T1.CUS_NM
        ,T2.CUS_ID, T2.ITM_ID, T2.EVL_LST_NO
  FROM  M_CUS T1
        ,T_ITM_EVL T2
 WHERE  T1.CUS_ID IN ('CUS_0002', 'CUS_0011')
   AND  T1.CUS_ID = T2.CUS_ID(+)
 ORDER BY T1.CUS_ID;
 
 